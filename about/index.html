<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>About - Captain's Journal</title>
    <link rel="stylesheet" href="/about/styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;600&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Pirata+One&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" type="image/x-icon" href="/images/favicon-32x32.png" />
    
    <!-- Primary Meta Tags -->
    <meta name="title" content="About The Captain's Journal - AI-Generated Pirate Adventures" />
    <meta name="description" content="Discover how AI technology brings pirate stories to life in The Captain's Journal. Learn about our unique blend of artificial intelligence and storytelling." />
    <meta name="keywords" content="pirate stories, AI storytelling, Captain's Journal, Jake Poulsom, Azure, OpenAI, text-to-speech, creative writing" />
    <meta name="author" content="Jake Poulsom" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://captains-journal.com/about" />
    <meta property="og:title" content="About The Captain's Journal - AI-Generated Pirate Adventures" />
    <meta property="og:description" content="Discover how AI technology brings pirate stories to life in The Captain's Journal. Learn about our unique blend of artificial intelligence and storytelling." />
    <meta property="og:image" content="https://captains-journal.com/images/og-image.jpg" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://captains-journal.com/about" />
    <meta property="twitter:title" content="About The Captain's Journal - AI-Generated Pirate Adventures" />
    <meta property="twitter:description" content="Discover how AI technology brings pirate stories to life in The Captain's Journal. Learn about our unique blend of artificial intelligence and storytelling." />
    <meta property="twitter:image" content="https://captains-journal.com/images/og-image.jpg" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/line-numbers/prism-line-numbers.min.css">
  </head>
  <body>
    <main>
      <!-- Navigation -->
      <nav class="main-nav" aria-label="Main navigation">
        <div class="nav-container">
          <div class="nav-logo">
            <a href="/">
              <img src="/images/pirate-ship.svg" alt="Captain's Journal" />
              <span>Captain's Journal</span>
            </a>
          </div>
          <div class="nav-links">
            <a href="/" class="nav-link">Home</a>
            <a href="/wtfisthis/" class="nav-link">What is the Captains Journal?</a>
            <a href="/intro/" class="nav-link">Meet the Crew</a>
            <a href="/about" class="nav-link active">Blog</a>
          </div>
        </div>
      </nav>

      <!-- Hero Banner -->
      <header class="hero-banner about-banner" role="banner">
        <div class="hero-content">
          <h1>Bringing the Journal to life</h1>
        </div>
        <div class="banner-footer">
          <div class="tagline">The Story Behind the Stories</div>
        </div>
      </header>

      <!-- Main Content -->
      <div class="content-wrapper">
        <article class="about-container">
          <!-- Project Story Section -->
          <section class="about-section">
            <h1>The Project's Origins</h1>
            <div class="about-content">
              <p>
                Working professionally in the IT space, i'm
                always trying to keep up with the latest technologies, and the
                latest trends. It all started when i saw an interview with the CEO
                of Microsoft, Satya Nadella, talking about the future of AI and
                how it will change the work space as we know it. He was
                specifically talking about AI Agents and how they eventually will
                replace all SAS applications.
                <br />
                (For those interested heres the interview:
                <a
                  href="https://www.youtube.com/watch?v=GuqAUv4UKXo"
                  target="_blank"
                  rel="noopener noreferrer"
                  >Satya Nadella on AI Agents</a
                >) <br />
              </p>

              <p>
                I thought to myself "Wow that sounds like a bold statement" but i
                hadn't really looked much into AI agents myself.
                <br />
                <br />
                So, i decided to look into it and see what all the fuss was about.
                I started to read about the latest tools and techniques, and how
                these "AI Agents" work. I purchased a subscription to openAI and
                started to play around with the API. I quickly discovered that
                with just a few lines of python code i could create an AI agent
                that could do simple tasks. I experimented with it for a few
                hours, giving it a few simple tasks to complete, but lacked
                inspiration to really leverage the full potential of the API.
              </p>
              <p>
                That was until i gave it the simple prompt -- "Your are a pirate,
                write a short story of your adventures"
              </p>
              <p>
                I was quite impressed with the results, from such a simple prompt!
                This is when i really started experimenting!
                <br />
                <br />
                Soon, before i knew it, i had created character profiles, back
                stories, locations, world building, pirate lore, and a whole lot
                more! I sat for hours reading the stories my agent was
                telling me, and i was hooked!
                <br />
                <br />
                Thats when i had the thought, "I wonder if other people would
                enjoy these wacky stories as much as i have?"
                <br><br> I had been looking
                for a creative project i could really sink my teeth into, and this
                seemed like a fun idea!
                <br />
                <br />
                and thus, the captains-journal was born.
              </p>

              <h2>Okay, heres what i'll do!</h2>
                I'll whip up a quick HTML page, host it in an Azure static website, write some simple code, host the text episodes in a Azure blobs storage and voila!
                <br>
                <br>
                Right ?
                <br>
                errrr Right............... ?
                <br>
                <br>
                <br>
                mwahahha, Jake your poor little innocent flower, you have no idea what your about to get yourself into!
                <br>
                <br>
                <h2>Humble Beginnings</h2>
                Okay, so at this point i now have an AI agent that is convinced it's a captain of a pirate ship.
                <br> 
                It can now generate short stories in a text format, and output the .txt files locally on my machine.
                <br>
                This is cool, but i want to make a web series with daily episodes. 
                <br>Currently the agent can generates a short pirate story, save it as a .txt file, but next time the scrpt runs, it generates a new story and overwirtes the current .txt file.
                <br>    
                <br>
                Okay, lets make some changes to the code!
                <br>
                <br>
                Firstly, i need to update the agent itself.
                <br>
                Currently all the agent knows is, it is the captain of at pirate ship, and should tell short stories.
                <br>I want to update the agent to be able to generate a new episode every day, the new episode should be a follow-up to the previous episode.
                If the last eipsode is captains_log_1.txt the next episode should be captains_log_2.txt and so on.
              <br>
                I started by updating the prompt for the agent.
              <br>
              <br>
                <img src="/images/prompt-update.png" alt="Prompt Update">
                <br>
                <br>


                I then made a few changes to the python script
                <br>
                The script now scans the local directy where the "captaions_log_X.txt files are created. If the script finds captains_log_1.txt it will then produce captains_log_2.txt, and so on.
                If no .txt files are found, the script will create a new episode.
                <br>
                <br>
                Okay, good start!
                <br>The agent is now able to generate a new episode every run, it also names the .txt file correctly, (Depending on if this is the first episode, or previous episodes exist) but the actual episodes and story telling is not consistant.
                <br>
                 <br>
                If i want to make a web series with daily episodes. For this to work, its extremely important that episdoes are consistant. Each episode should be a continuation of the previous one.
                <br>
                This won't work if the story arch keeps changing, characters are suddenly in different locations, doing different things etc...
                <br>
                <br>
                hmmmm what if i could generate a new episode every day, each episode following the same consistent story arch?
                <br>
                <br>
                <h3>Enter The Captains assistant!</h3>
                Okay, so i needed a way for the AI to keep track of the story, character arcs, locations visited, and especially what happened in the previous episode.
                  <br>
                  I managed to achieve this by adding an assistant to the prompt.
                  <br> The Assistant is responsible for reading all previous logs generated for the story so far.
                  <br>
                  <br>
                  So how does this work?
                  <br>
                  <br>
                  Just like like the main agent, the assistant first checks the local file directory for any existing .txt files.
                  If any .txt files are found, the assistant then reads through all content and comits it to memory.
                  The main agent then receives a new prompt, with the assistant's memory as the context.
                  <br>
                  <br>
                  In this case, if text files are found the agent will receive the prompt -  "Please write the next log entry, continuing the story from all previous logs while maintaining consistency in the story and character development" 
                  <br>
                  <br>
                  If no text files were found, the agent will receivve the prompt - "You can write a complete log entry without worrying about length restrictions. Focus on maintaining story consistency and providing a complete narrative."
                  <br>
                  <br>
                  I'm now able to generate consistent episodes that maintain a smooth and continuous story arc, ensuring each installment seamlessly connects to the next.
                  <br> This allows for ongoing character development, engaging plot progression, and a more immersive storytelling experience.
                  <br><br>
                  Pretty cool right?
                  <br>
                  <br>
                  but, what if we didn't have to read the stories ourself?
                  <br>
                  <br>
                  <br>
                  
                <br>  
                <img src="/images/captains_asistant.png" alt="Assistant">
                <h2>The Voice of the Captain</h2>
                This is where things start to get really interesting. (and also a little wacky üòÇ)
                <br>
                <br>
                I'm now able to generate a new episode every run, with a continous story arch, characters, locations, and a continous story.
                but it's just text.....
                <br>
                what if i could generate a audio version of each episode?
                <br>
                <br>
                Okay, time to hit the "Google-kung-fu" lets see what options i have!
                <br>
                <br>
                Oh snap! OpenAI has a text to speech API!
                <a href="https://platform.openai.com/docs/guides/text-to-speech" target="_blank" rel="noopener noreferrer">OpenAI Text to Speech API</a>
                <br>
                <br>
                Okay lets see what we can build!
                <br><br>
                After reading through the documentation it was actually pretty quick and easy to get a prototype up and running.
                <br>
                I went with the voice "Ash" as i felt this was the voice that sounded best for a narrator. However, i wansn't 100% happy with the voice, so i deciced to experiment a bit, and this is where things get a bit wacky üòÇ
                <br><br>
                First i tried cloneing my own voice, and creating an AI version of myself to read the text.
                This actually worked better than i expected, which made it all the more creepy!
                <br> One thing is listening to your own voice, but listening to yourself say things you've neveer said, or read words completely different to how you would normally read them, was just a little to weird for me.
                <br><br>It also tried to make me sound waaaaaaaaaaaaay posher then i am, which again, doesn't really work for a pirate story.
                <br><br>For those interested - here is a little preview of AI Jake!

                <!-- Add the first audio player -->
                <div class="audio-preview">
                    <h3>Jake the Narrator</h3>
                    <audio controls>
                        <source src="/files/Jake_the_narrator.mp3" type="audio/mpeg">
                        Your browser does not support the audio element.
                    </audio>
                </div>

                <br>
                <br>
                Next up, i dawned my pirate hat and eyepatch, and attempted to make a pirate AI voice. 
                <br><br>
                This was achieved by reading a bunch of text in my best pirate voice.
                Needless to say, this evening i got alot of strange looks from my better half, as i sat yelling pirate slurs to myself for a good couple of hours.
                <br><br>
                This it what It ended up producingüòÇüòÇ

                <!-- Add the second audio player -->
                <div class="audio-preview">
                    <h3>Jake the Pirate</h3>
                    <audio controls>
                        <source src="/files/Jake_the_pirate.mp3" type="audio/mpeg">
                        Your browser does not support the audio element.
                    </audio>
                    <br><br>
                    As i sit writing this blog, i'm still not entirely sure what voice i'm going to go with for the finished product. I still have alot of experimentation to do with different API's and prodcuts, so i guess you'll have to wait and see!
                </div>

                <br>
                <br>
                <h2>Token Drama</h2>
                4096, a number that probablly doesn't mean anything to most people, but to me it was a number i needed to overcome!
                <br><br>
                So what is this mysterious number 4096 you ask? - 4096 is the "token limit" for any OpenAI API reponse.
                <br>
                What this means is, the maximum output for each openAI API call can not exceed 4096 tokens.
                <br><br>
                Okay, so what the hell is a a "Token" ? and how are they calculated?
                <br><br>
                Tokens are calculated by the number of words in the text. Tokens are pieces of words or characters that the AI processes to understand and generate text.
                <br>They are not the same as words but represent fragments of words, whole words, or even punctuation.
                <br>
                <br>
                In English, 1 token ‚âà 4 characters (on average).
                <br>
                A single word can be multiple tokens, especially if it's complex.
                <br>
                Short words like "a" or "is" count as 1 token.
                <br>
                Longer words like "artificially" may be split into multiple tokens.
                <br><br>
                For example:
                <br>
                <table></table>
                <br>
                "Hello"	= 1 token
                <br>
                "Captains"	= 1 token
                <br>
                "Extraordinary"	= 2 tokens
                 <br>
                "Pirate's adventure!" =	4 tokens
                 <br>
                "The treasure is near."	= 5 tokens
                <br><br>
                Since 1 token is, on average, 4 characters in English, and the average English word is around 5 characters long (including spaces), we can estimate that an output of 4096 tokens would contain roughly 3280 words.
                <br>At a normal narration pace of 130 words per minute, this would translate to about 25 minutes of audio. (According to ChatGPT)
                <br><br>
                Wait a second! Why are my audio files only around 3 and a half minutes long ?!?!
                <br><br>
                Is my maths completely off? or is something else going on her?
                <br><br>
                Errrmmm..... i'll be right back, i need to figure out whats going on! (Yes i'm finding this out now as i write this blog)
                <br><br>
                Oh hi there! Im back!
                <br>
                Sure, for you, it's like i never left, but i've actually been gone for hours, yup, thats right, hours! Another rabit hole into the depth of AI.
                <br><br>but hey! I learnt some stuff when i was gone.... wanna hear it ?
                <br><br>
                Okay heres the deal.....
                Turns out there is a direct correlation between the number of tokens in the input and the output.
                <br><br>
                How Input Size Affects Output
                <br><br>
                GPT-4 Turbo has a max context length of 128k tokens (input + output combined).
                <br>
                Output tokens are capped at 4096 per request (this is a separate limitation).
                <br>
                The more input tokens you use, the fewer output tokens are available.
                <br>Allthough this is a limitation first kicks in after 120k tokens.
                <br>
                <br>
                <table class="token-limits">
                  <thead>
                      <tr>
                          <th>Input Size (Tokens)</th>
                          <th>Max Possible Output (Tokens)</th>
                      </tr>
                  </thead>
                  <tbody>
                      <tr>
                          <td>1,000</td>
                          <td>4,096 ‚úÖ <span class="note">(Full response possible)</span></td>
                      </tr>
                      <tr>
                          <td>3,000</td>
                          <td>4,096 ‚úÖ <span class="note">(Full response possible)</span></td>
                      </tr>
                      <tr>
                          <td>10,000</td>
                          <td>4,096 ‚úÖ <span class="note">(Still full output possible, as long as the total stays under 128k)</span></td>
                      </tr>
                      <tr>
                          <td>120,000</td>
                          <td>8,000 ‚ö†Ô∏è <span class="note">(Limited output tokens remaining)</span></td>
                      </tr>
                      <tr>
                          <td>125,000</td>
                          <td>3,000 ‚ö†Ô∏è <span class="note">(Very limited output tokens remaining)</span></td>
                      </tr>
                      <tr>
                          <td>127,000</td>
                          <td>1,000 ‚ö†Ô∏è <span class="note">(Critically low output tokens remaining)</span></td>
                      </tr>
                      <tr>
                          <td>128,000</td>
                          <td>0 ‚ùå <span class="note">(No room for output! Model won't generate anything)</span></td>
                      </tr>
                  </tbody>
              </table>
                <br>
                Oh dear, maybe i'm using to many tokens in my input, and thats the reason my output is so short?
                <br><br>
                Okay back to coding, there must be a way to get an overview of the token usage.
                <br><br>
                Alright cool, manged to setup some code to monitor token usage, lets run some tests and see how we're looking!
                <br>
                <br>
                <img src="/images/token-usage.png" alt="Token Usage">
                <br>
                <br>
                Okay according to my logs, i'm not even close to hitting 120k tokens (Which is the point where output limits would start to accour).
                <br><br>
                As you can see on the above screenshot, my prompt is only using 5035 tokens (This test was done generateing the third episode in a on-going saga, so there ware 2 previous logs that needed to be loaded to memory, these logs were at total of 1486 tokens)
                <br>Giving us a grand total of 6033 tokens.
                <br>
                <br>
                So what exactly is happening here?
                <br><br>
                Honestly i'm not exactly sure, but i do know, i'm not using anywehre near 120k tokens on my input. From what i can tell, the agent maybe just feels that the entry it has given is adequate, and doesn't need to add any more detail.
                <br><br>
                Prehaps i'm overcomplicating things. Maybe i should tell the agent to make each story be 4095 tokens in length.
                <br><br>
              
                <img src="/images/Giveme4096tokens.png" alt="Give 4095 tokens">
                <br><br>
                At the same time i also updated the code to actaully display the toke size of the output. (Ouput tokens)
                <br><br>
                Lets see how this works!
                <br>
                <br>
                Test 1:
                <br>
                <img src="/images/outputtokens1.png" alt="Token Usage">
                <br>
                Test 2:
                <br>
                <img src="/images/outputtokens2.png" alt="Token Usage">
                <br><br>
                Wow, not even close to 4096! I'm not evening close to hitting the input limit, or the output limit.
                <br>
                It also completely ignored the fact i told it specifically to use all 4096 tokens.
                <br><br>
                Just to elaborate, it's not that i want it to output exactly 4096 tokens each time, that would be way to long for a daily episodeic adventure, but i definitely want more than 933 tokens..
                <br><br>
                Alright back to the drawing board, time to read up on the OpenAI documentation *AGAIN* and see if i can find anything else that can help me out.
                <br><br>
                Okay, turns out there is something called a"Stop_reason" parameter in the API.
                <br>
                Seems there can be mutiple reasons why the model may stop generating content.
                <br>
                <br>
               *stop* = The Model chose to stop early
                <br>
                *length* = The Model hit the max token limit
                <br>
                *content_filter* = OpenAI blocked part of the output
                <br> 
                *null* = The Model stopped but no reason given
                <br>
                <br>
                Again, time to add more dedugging and logging to the code, lets see if we can find the reason why the model is stopping.
                <br>
                <br>                 
                <img src="/images/finishreason.png" alt="Stop Reason">
                <br>
                <br>
                WELL SON OF A BITCH! IT JUST STOPPED, "BECAUSE IT FELT LIKE IT", EVEN THOUGH DADDY SPECIFICALLY SAID "GIVE ME 4096 TOKENS"
                <br>
                <br>
                Okay lets try giving it the stop=none parameter -  This means the model *should* not stop no matter what.
                <br><br>
                <img src="/images/stopnone.png" alt="Stop None">
                <br><br>
                We'll also give it a little more convincing via a new prompt.
                <br><br>
               <img src="/images/dontstopearly.png" alt="Don't stop early">
               <br><br>
               YOU OW ME 4096 TOKENS, AND DADDY WANTS HIS TOKENS! - Just like Brad pit wants his scalps...
               <br>
               (This is Inglorious bastards reference, if you haven't seen the film, stop reading this blog and go watch it NOW!)
               <br>
               <br>
               Did you watch it ?
               <br><br>
               Amazing right? Quentin Tarantino really is a genius!
               <br><br>
               eeerr,, ummm.. anywaaaaayyyyyy.... Where were we?
               <br><br>
               Ah yes, the disobedience of my creation!
               <br>Lets try run the model again with the new improved prompt.
               <br><br>
               <img src="/images/disobeyed.png" alt="Disobeyed">
               <br><br>
               Disobeyed by my creation once again... 1161 tokens....
               <br>
               <br>
               "Cocks Shotgun"
               <br>
               <br>
               Iv'e played with this for a few hours now, and i'm not able to get the model to ouput anywhere near to 4096 tokens, no matter how hard i try. I have however managed to get longer outputs in general.
               I'm now averaging around 1200 tokens per episode, which is around 5 minutes of audio, so that's a slight improvement.
               <br>
               <br>
               One thing i have noticed however, is that the model seems to generate longer and longer outputs as the series goes on.
               <br>
               I'm presuming this is probably because i'm constantly feeding the model with the previous episodes, giving it more and more data to work with.
               <br>
               So presumably, the series will get more and more detailed as it goes on.
               <br>
               <br>
               I may re-vist this later, but for now i'm going to focus on the next set of problems.
               <br>
               <br>
               <h2>Temperature</h2>
               <p>
                 Before I completely move on from this token drama, I'd like to touch quickly on the "Temperature" parameter, as this can essentially also effect the output length.
               </p>
               <p>
                 Temperature is a key setting in AI models (like GPT-4 Turbo) that controls how random or predictable the AI's responses are. It affects the creativity, coherence, and unpredictability of the output.
               </p>
               <p>
                 The temperature parameter is a float between 0 and 1.
               </p>

               <div class="temperature-section">
                 <h3>üî• How Temperature Works</h3>
                 
                 <div class="temperature-level">
                   <h4>Low Temperature (0.1 - 0.4) ‚Üí More Predictable, Logical Responses</h4>
                   <ul>
                     <li>The AI sticks to safer, more deterministic answers</li>
                     <li>Good for technical, fact-based, or structured tasks</li>
                     <li>Example: AI follows strict patterns and rarely improvises</li>
                   </ul>
                 </div>

                 <div class="temperature-level">
                   <h4>Medium Temperature (0.5 - 0.7) ‚Üí Balanced Responses</h4>
                   <ul>
                     <li>A mix of coherence and creativity</li>
                     <li>Ideal for storytelling, brainstorming, and engaging conversations</li>
                     <li>Example: AI follows logical structures but adds some variation and personality</li>
                   </ul>
                 </div>

                 <div class="temperature-level">
                   <h4>High Temperature (0.8 - 1.2) ‚Üí Wild, Creative, Unpredictable</h4>
                   <ul>
                     <li>The AI takes risks and improvises more</li>
                     <li>Great for jokes, poetry, and wacky storytelling</li>
                     <li>Example: AI generates surreal, chaotic, or unexpected responses</li>
                   </ul>
                 </div>

                 <div class="pirate-example">
                   <h3>üé≠ How Temperature Affects a Pirate AI</h3>
                   <p>Let's say we ask the AI: "What does a pirate say when he finds buried treasure?"</p>

                   <div class="temperature-example">
                     <h4>üö® Low Temperature (0.2)</h4>
                     <p class="response">"Arrr, we found the treasure! Let's take it back to the ship."</p>
                     <p class="note">(Boring, expected, factual.)</p>
                   </div>

                   <div class="temperature-example">
                     <h4>‚öñÔ∏è Medium Temperature (0.6)</h4>
                     <p class="response">"Shiver me timbers! This be a chest of gold fit for a king! Now who be havin' a key?"</p>
                     <p class="note">(More personality, but still structured.)</p>
                   </div>

                   <div class="temperature-example">
                     <h4>üî• High Temperature (1.0+)</h4>
                     <p class="response">"Blimey! It be a chest full o' socks! NOOO! The map was upside down again!"</p>
                     <p class="note">(Completely chaotic and hilarious!)</p>
                     <br>
                     I'm building a chaotic comedic pirate adventure, i think we all know which setting i'll be going with!
                   </div>
                 </div>
               </div>
               <h2>A quick recap</h2>
               Okay, lets quickly review where we're at!
               <br><br>
               We now have an AI agent thats convinced it's the most feared and legendary pirate to ever sail the seas. ‚úÖ 
               <br><br>
               It can produce a believable and engaging story, with a mix of personality and structure. ‚úÖ
               <br><br>
               It can now consistantly follow the story structure and keep story lines and characters consistent. ‚úÖ
               <br><br>
               We have a way to monitor the overall token usage. ‚úÖ
               <br><br>
               We have a way to control the temperature of the output. ‚úÖ
               <br>
               <br>
               Outputs are generally larger than 1200 tokens, which is a good start! ‚úÖ
               <br><br>
               Model stil defies daddys orders at giving an output of anything close to 4096 tokens! ‚ùå
               <br><br>
               <h2>Txt Chunks n' Audio Chunks -  The Departening!</h2>
               Alright, another day another problem!
               <br><br>
               With the model now consistantly outputting a good length of text, a new issues arises.
               <br>
               <br>
               Turns out the OpenAI TTS (text to speach) API has a max input limit of 4096 Characters per request, which is aprroximately 5 minutes of audio.
               <br><br>
               (It's imporatnt to mention here, we are now talking about characters, NOT tokens)
               <br><br>
               Some of the journal entries are over 4096 characters, but some are not......
               <br>
               The ones that are over 4096 are getting automatically truncated when being passed to the TTS API.
               <br>
               This means, if a journal entry is over 4096 (Lets say for example we have a journal entry of 7000 characters)
               The TTS API will only pass the first 4096 characters to the API, generate the audio for that chunk, then just stop.
               <br>
               Giving you only 4096 characters of audio, and leaving the rest of the journal entry untold.
               <br><br>
               This is an issue...
               <br><br>
               Luckily this is a fairly simple problem to solve.
               <br>
               We know the limit for each TTS submission can max be 4096 characters, so we just need to split each journal entry into chunks of less than 4096 characters.
              <br>(Remembner we are now talking about characters, NOT tokens)
              <br><br>
              Alright, lets play it safe and split each journal entry into chucks of 4000 characters, this way we are sure we will not hit the limit.
              <br>
              This can easily be done by doing a some simple string manipulation in the code.
              <br>
              Some of the important things to consider however, is making sure the string split doesn't accour mid word, or mid sentence.
              <br>
              I found the best way to do this, was to make sure each split happened after a full stop.
              <br>
              <br>
              <img src="/images/split.png" alt="Split">
              <br>
              <br>
               Okay great, we are now able to pass a full journal entry to the TTS API, without missing any data!
               <br><br>
               but rarely are things so simple...... 
              <br><br>
               Beacuase the text journal entries are being split into seperate chunks, and than fed to the TTS API in chunks of 4000 characters, this means the audio files outputted by the TTS API are also split into the same 4000 character chunks.
               <br><br>
               Now we find ourselves in the situation, were we can have up to 3 seperate audio files for one journal entry.
               <br><br>
               This is no good... The plan is to have a web series, were the audio files will be streamed directly from the website.
               <br>
               This should be seemless for the end user, and they should only have to deal with one audio file per episode.
               <br><br>
               <img src="/images/depart.png" alt="Departing">
               <br><br>
               Shit......
               <br>
               <h2>A small sidetrack for context</h2>
               Okay, so at this point i knew i wanted to "stitch" the audio files together, but i had no idea how i was going to achieve this.
               <br><br>
               I think this is a good point in the blog to tell you a little about myself.
               <br>
               I already mentioned i work in the IT industry, and have done for many years, but......
              <h4>i'm not not a front end developer, i'm not a back end developer, and i'm certainly not a software engineer!</h4>
               I work as a Cloud Architect, where my primary focus is designing and implementing cloud solutions inside Microsoft 365 and Azure.
               <br>
               (These skills will will come into play later in the adventure, but for now, lets focus on the code.)
               <br><br>
               My standard day mainly consists of designing and maintaining IT infrastructure, with a large focus on cybersecurity and compliance.
               <br>
               This means i have a pretty good grasp of Powershell, and creating simple scripts to assist in my daily tasks, but Python, javascript, and HTLM is not an area i'm extremely well versed in.
               <br><br>
               I think this is important context to have for the upcoming sections of this blog.
               <br>
               <br>
               Okay back to the problem at hand! - Stitching the audio files together.
               <br>
               <br>
               Time to hit the "Google-fu" and see if i can find a way to achieve this!
               <br><br>
               During my time googleing for a solution, i came accross an intresting peice of software, that was about to change the game completely....
               <br>
               <br>
               <h2>Cursor has entered the chat!</h2>
               <br><br>
               <a href="https://www.cursor.com/" target="_blank">
                 <img src="/images/cursorlogo.png" alt="Cursor Logo" style="width: 20%; border-radius: 50%;">
               </a>
               <br><br>
               What is Cursor you ask?
               <br><br>
               Cursor is an AI-powered code editor designed to assist developers by integrating AI-driven coding features, such as autocompletions, debugging assistance, and smart code suggestions.
               <br>
               It is built as an AI-enhanced alternative to traditional code editors like VS Code and integrates with OpenAI's GPT models to help programmers write, refactor, and debug code faster.
               <br>
               <br>
               Up until this point, i had been using VS Code (Which i really like) cursor is basicly VS code on steroids, with it's own brain.
               <br>
               This drasticly improved my workflow, and the speed at which i was able to generate code!
               <br><br>
               I went from spending a bunch of time googling Python syntax, debugging code, and trying to figure out the best way to do something, to just asking Cursor.
               <br>
               <br>
               I was now an UNSTOPPABLE CODING MACHINE!
               <BR></BR>
               <div class="tenor-gif-embed" data-postid="27665965" data-share-method="host" data-aspect-ratio="1.77778" data-width="100%"><a href="https://tenor.com/view/hacker-meme-work-hard-you-can-do-it-gif-27665965">Hacker Meme GIF</a>from <a href="https://tenor.com/search/hacker-gifs">Hacker GIFs</a></div> <script type="text/javascript" async src="https://tenor.com/embed.js"></script>
               <br><br><br>
                I know this is a touchy subject for many people.
               <br>
               Many people are understandably concerned about AI replacing jobs and impacting income. While those concerns are valid, what I will say is..."
               <br>
               <h4>If you are a front end devleoper, web developer, or anyone whos sepends most of their time in a IDE developing code.
                <br><u>If you are not uisng an AI assistant, you are wasting your time and your companies time!</u></h4>
               Yes yes, i know this is a bold statement and this may trigger some people, belive me, i've had my fair share of internal battles on this topic.
               <br><br>
               I remember the early days of chatGPT.
               <br>
                I'd watch junior IT staff generating Powerscripts to solve smalll problems.
               <br>
               Back then it was 50/50 if the script even worked!
               <br> The Junior IT staff member had no freaking idea what the code did, how it worked, or what it could potentially do to the machine is was running on.
               <br>
               I always thought to myself "wow thats so dumb, you really don't learn anything from just generating code you don't understand"
               <br><br>
               I do still feel this way today, but with that being said, i think it comes down to how you use these tools.
               <br><br>
               If you are 100% reliant on an AI to generate all of your code (and you have no understanding of whats being displayed on your screen) your not going to learn anything.
               <br> However, if you refuse to embrace these tools, your competition will outpace you‚Äîbecoming more efficient, more effective, and ultimately leave you behind.
               <br><br>
               I think i'll end this section with a quote from Charles Darwin.
               <br><br>
              "It is not the most intellectual of the species that survives; it is not the strongest that survives; but the species that survives is the one that is able best to adapt and adjust to the changing environment in which it finds itself"
               <br>
               <br>
               <h2>Ummm, Jake, what about the audio files?</h2>
               Oh yea, i almost forgot about that, things got a little bit deep back there didn't they?
               <br><br>
               So umm yea.. I basicly just told Cursor, "Yo dawg, i got a problem with some audio files, wanna hook a brother up?"
               <br>
               <br>
               Okay, thats not exactly how it happened.....
               <br><br>
                While googling for a solution, i found some information obout a python libary called "pydub" which could be used for manipulating audio files.
                <br>
                <br>
                "Pydub is a Python library used for manipulating and processing audio files. It provides an easy-to-use API for loading, converting, trimming, merging, and applying effects to audio files without needing deep knowledge of audio processing."
                <br>
                <br>
                With a little help from Cursor, i was able to whip some code together, and VOLIAAA, we now have a way to stitch audio files together!
               <br>
               <br>
               No more part1.mp3, part2.mp3, part3.mp3, no more having to worry about the audio files being cut off mid sentence.
               <br>
               <br>
               Lovely...
               <br>
               <br>
               I would show you the code, but uuumm some stuff happened and i errrrr... don't have it anymore, but if i told you that now, we would be getting ahead of ourselves!
               <br>
               <br>
               <h2>Early beginnings of the website</h2>
               Oh yea, remember at the start of this blog i mentioned i was going to build the website from scratch?
               <br>
               <br>
               i think i mentioned .....
               <br>
               <br>
               <b>"Okay, heres what i'll do!</b>
               <br>
               I'll whip up a quick HTML page, host it in an Azure static website, write some simple code, host the text episodes in a Azure blobs storage and voila!"
               <br>
               <br>
               yeeaaaa..... we're only just getting to this part now!
               <br>
               <br>
               Anyhow, I'll be hosting the website in an Azure static website (Suprise Suprise!)
               <br> <BR>
              Frist things first, lets Create a completely new Resource Group in Azure that will house all the resource we will use for this project.
               <br><br>
               RG-CaptainsLog - Check ‚úÖ 
               <br><br>
               The astute amounst you may ask - "why are there so many things called "CaptainsLog"? and not "Captains Journal"? and why do you keep refering to "journal entries" as "log entries".
               <br>
               <br>
               and to that i say - SHHHHHHH be patient, we'll get to that!
               <br>
               <br>
               Okay resource group is deployed, now lets deploy the static website.
               <br>
               <br>
               <img src="/images/rgdeployed.png" alt="Resource Group">
               <br><br>
               A few notes on the Azure Static Website. - It is completely Free, supports custom doamins, and even hosts a free SSL certificate.
               <br>
               Crazy Value! - I presume this is Microsofts way of getting people slowly onboard, and when their website explodes in popularity, their forced to move up to the paid teir.
               <br><br>
               However, there are a few limitations to be aware of in the free teir:
               <br><br>
               Bandwidth: There's a monthly data transfer limit of 100 GB.
               <br>
               Storage Capacity: Each app is limited to 250 MB of storage.
               <br>
               Custom Domains: You can configure up to 2 custom domains per app.
               <br>
               Staging Environments: The Free plan allows for 3 staging environments per app.
               <br>
               Service Level Agreement (SLA): The Free plan does not include an SLA, which means there's no guaranteed uptime or support.
               <br><br>
               For my use case, i'm not expecting any of these limitations to be an issue.
               <br><br>
               <img src="/images/staticsite.png" alt="Static Website" style="width: 70%;">
               <br><br>
               I choose to use Github Actions to deploy the static website.
               <br>
               This means i can push my code to my Github repository, and the Github Actions workflow will deploy the static website to Azure.
               <br><br>
               To put this in simple terms: Whenever i make any changes to my code, i can then "upload" the new code to my Github repository. Inside my Github repository there is a small "worker bot" that is constantly monitoring for new changes.
               <br>
               If the worker bot detects a new change, it will then trigger the Github Actions workflow and deploy the new changes to the static website.
               <br>
               <br>
               The new code will then be displayed correctly on the website. - Nice and simple work flow!
               <br><br>
               Great! Now i need a custom domainname for the website, i'm thinking "Captainslog.com" - Yea you're allready ahead of me here right ?
               <br>
               <br>
               <img src="/images/domainname.png" alt="CaptainsLog - Domain Name">
               <br><br>
               SON OF A BITCH!
               <br><br>
               <div class="tenor-gif-embed" data-postid="23416426" data-share-method="host" data-aspect-ratio="1.77778" data-width="50%"><a href="https://tenor.com/view/so-pissed-im-work-mad-gif-23416426">So Pissed GIF</a>from <a href="https://tenor.com/search/so-gifs">So GIFs</a></div> <script type="text/javascript" async src="https://tenor.com/embed.js"></script>
               <br><br>
               After alot of back and fourth brainstorming different name ideas, and constantly being disapointed by the fact the domain was already taken, i finally settled on "captains-journal.com"
               <br><br>
               I brought the custom domain, did some wizzardry with the DNS settings, and boom! We now have a website hosted on Azure!
               <BR> Theres nothing on it, but we have a website!
               <BR></BR>
               <img src="/images/itsawebsite.png" alt="Website" style="width: 70%;">
               <br><br>
                <h2>The website vision</h2>
                I knew exactly what i wanted for the website, wherever or not i could achive it, would be another matter.
                <br><br>
                Heres what i had in mind:
                <br>
                <br>
                <b>Attractive visual design</b> - Modern, clean, and responsive, with a clear pirate theme.
                <br>
                <b>Simple layout</b> - Easy to navigate, i didn't needs tons of different pages.
                <br>
                <b>Smooth audio playback</b> - Streaming of audio files directly from Azure Blob Storage, with an easy to use embedded audio player.
                <br>
                <b>Subscribe Feature</b> - I wanted users to be able to subscribe to the website, and receive email notification when a new episode is released.
                <br>
                <b>Character bios</b> - I've developed many characters for the series, it would be cool having some sort of character bio section, with AI generated art of my character designs.
                <br>
                <b>Mobile Performance</b> - I wanted the website to be mobile friendly, alowing users to listen to the episodes on the go.
                <br>
                <b>100% autonomous</b> - Episodes should be generated automatically on a set schedule, automatically upoaded to the azure blob storage and presentated ready for streaming on the website (Without any interaction from me)
                <br><br>
                When i realease this demon spawn to the world, it will be completely out of my hands!
                <br>
                <br>
                Time to get to work!
                <br>
                <br>
                With my secret weapon(Cursor), i was able to whip up a quick prototype for the website in no time at all.
                <br>
                <br>
                Obviously the website went through many iterations, heres a little taster of one of the early iterations.
                <br>
                <br>
                <img src="/images/originalwebconcept.png" alt="Original Web Concept" style="width: 70%;">
                <br><br>
                I feel like it improved alot since then, but i'll let you be the judge of that.
                <br><br>
                <h2>A quick recap of the AI Agent</h2>
                Okay it's been a while since we last talked about the AI Agent, so i'll quickly recap what we have done so far. 
                <br>
                <br>
                <b>We have an AI Agent that belives it's the most feared and legendary pirate to ever sail the seas.</b> ‚úÖ 
                <br><br>
                <b>The AI Agent can generate a believable and engaging story, with a mix of personality and structure.</b> ‚úÖ 
                <br><br>
                <b>We have an AI Assitant that keeps track of the story and keeps the characters and their story archs consistent.</b> ‚úÖ 
                <br><br>
                <b>We have a way to monitor our overall token usage.</b> ‚úÖ 
                <br><br>
                <b>We have a way to control the temperature of the output.</b> ‚úÖ 
                <br><br>
                <b>We have a way to split the journal entries into chunks of 4000 characters.</b> ‚úÖ 
                <br><br>
                <b>We have a way to then stitch the audio files back together, outputting a single mp3 file.</b> ‚úÖ 
                <br><br>
                <b>We still have a disobiedient model, that likes to defy daddys orders, and will never give an output of anything close to 4096 tokens.</b> ‚úÖ 
                <br><br>
                In a nutshell, we are able to run the script, each time the script runs it will generate a new journal entry which is a continuation of the previous entry.
                <br><br>
                I'm pretty happy with the progress on the AI Agent, so far. The stories it tells are quite entertaining, yet i'm still constantly changing my prompts to try and get the best possible results.
                <br>I'll probably be consistantly changing the prompts, right up until i go live with the first episode.
                <br><br>
                The one thing i'm not 100% happy with at the moment is the voice of the AI Agent.
                <br>
                I still haven't found the right voice to tell the story, but luckily this is not something that takes alot of code to change.
                <br>
               <h3>Okay, time to move the AI Agent to Azure -  but what's an Azure Function?</h3> <img src="/images/azurefunctions-icon.svg" alt="Azure Function">
                <br>

                <br>
                An Azure Function is a serverless computing service that allows you to run small pieces of code (functions) in the cloud without managing a full server or infrastructure.
                <br>
              Think of it as "event-driven, auto-scaling code execution" in the cloud. It automatically scales, only runs when needed, and you pay only for what you use.
           <br><br>
           1Ô∏è‚É£ You write a function ‚Üí A small piece of code that does a specific task.
           <br><br>
           2Ô∏è‚É£ It is triggered by an event ‚Üí Example: HTTP request, file upload, database change.
           <br><br>
           3Ô∏è‚É£ Azure automatically runs the function when triggered.
           <br><br>
           4Ô∏è‚É£ It scales up or down automatically based on demand.
           <br><br>
           Oh and did i mention it's free?
           <br><br>
           Yes, there is a completely free teir for Azure functions! There are of course some limitations (some of which did create some extra headaches and extra work for me)
           <br><br>
           The Free Tier provides 1 million requests and 400,000 GB-seconds of resource consumption per month at no charge.
           <br><br>
           Again, AMAZING value! (I swear this is not sponsored by Microsoft, i'm not even sure they know i exist)
           <br><br>
            There are however a few caveats to be aware of with the free teir.
           <br><br>
           The Consumption Plan does not support VNet integration - This is not a deal breaker, it means intergrating with some Azure resources a little more difficult, but it does however support managed identity, so that helps.
           <br><br>
           "Cold Start Latency: Infrequently used functions may experience delays during startup, potentially impacting performance for time-sensitive applications"
           <br><br>
           This is the biggest issue with the free teir. It's not an issue with this particular function, but it will be a issue with some of the functions we build later.

          <h3>Okay now we know what an Azure Function is, but why do i want to move my code there?</h3>
          As i mentioned earlier, once the website goes live, i want everything to be completely autonomous.
          <br>
          <br>
          This means i want the AI Agent to be able to generate a new episode, upload it to the Azure Blob Storage, and update the website with the new episode.
          <br>All without any interaction from me.
          <br>
          <br>
          We can achieve the first step of this plan by using a Time-Trigger in the Azure Function - Once we have moved the code into its new home, inside a cozzy Azure Function, we can set the function to run at a specific time each day.
          <br>
          This will however require quite a bit of modifcation to the existing code!
          <br><br>
          Remember, up until this point, the AI Agent was running on my local machine. This means it's always been generating files and saving them locally in the same folder as the script.
          <br><br>
          We now need to setup an Azure Storage Account and modify the code to save the files there instead of locally.
          <br>
          <br>
          Nothing to fancy here, i'll just deploy the cheapest storage Account possible, LSR, general purpose V1, no zone redundancy or anything like that.
          <br>
          <br>
          <img src="/images/storageaccount.png" alt="Storage Account" style="width: 70%;">
          <br><br>
          <br>
          Inside the storage account, i'll create a new container called "captainslog" (yea, yea, this was actually before the whole domain name debacle, but fuck it, we are keeping the name now!)
          <br>
          <br>
          <img src="/images/storagecontainer.png" alt="Storage Container" style="width: 70%;">
          <br><br>
          Alright cool, we now have all of the infrastructure in place, we can now start to modify the code to save the files to the Azure Blob Storage instead of locally on my machine.
          <br>
          <br>
          Okay, there are a few different ways we could do this, but I ended up using Access Keys to access the Azure storage account from the function.
          <br>
          <br>
          Another cool thing about Azure Functions, is that they have support for enviroment variables - This means i can hide things like API keys, connection strings, and other sensitive information in the function app environment variables.
          <br><br>
          Which means i can Share the code with you guys!
          <br>
          <h3>Here's the full code for the AI Agent Function</h3>
          <pre class="line-numbers"><code class="language-python">
            from openai import OpenAI
            from azure.storage.blob import BlobServiceClient
            import azure.functions as func
            import re
            import logging
            import os
            from io import BytesIO
            
            #Updated
            
            client = OpenAI(
                api_key=os.environ["OPENAI_API_KEY"]
            )
            
            # Initialize Azure Blob Storage client
            connection_string = os.environ["AZURE_STORAGE_CONNECTION_STRING"]
            blob_service_client = BlobServiceClient.from_connection_string(connection_string)
            container_name = "captainslog"  # Name of your container
            container_client = blob_service_client.get_container_client(container_name)
            
            def natural_sort_key(s):
                """Helper function to sort strings with numbers naturally"""
                return [int(text) if text.isdigit() else text.lower()
                        for text in re.split(r'(\d+)', s)]
            
            def main(mytimer: func.TimerRequest) -> None:
                try:
                    logging.info('=== NEW FUNCTION EXECUTION STARTING ===')
                    
                    # Initialize previous_logs list
                    previous_logs = []
            
                    # List all blobs in the container
                    logging.info("Starting to list blobs in container...")
                    all_blobs = list(container_client.list_blobs())
                    logging.info(f"Found {len(all_blobs)} total blobs in container")
                    for blob in all_blobs:
                        logging.info(f"Found blob: {blob.name}")
            
                    # Only get .txt files and sort them
                    log_files = sorted([blob.name for blob in all_blobs 
                                      if blob.name.startswith("Captains Log day") and 
                                      blob.name.endswith(".txt")],
                                     key=natural_sort_key)
                    logging.info(f"Filtered to {len(log_files)} log files: {log_files}")
            
                    # Determine the next day number
                    next_day = 1  # Default to day 1 if no files exist
                    if log_files:
                        # Get the most recent log file
                        latest_log = log_files[-1]
                        logging.info(f"Latest log file found: {latest_log}")
                        # Extract the day number from the filename using regex
                        day_match = re.search(r"Captains Log day (\d+)\.txt", latest_log)
                        if day_match:
                            next_day = int(day_match.group(1)) + 1
                            logging.info(f"Extracted day number: {next_day-1}, next day will be: {next_day}")
                        else:
                            logging.warning(f"Could not extract day number from filename: {latest_log}")
                            raise ValueError("Invalid log file name format")
                    else:
                        logging.info("No existing log files found, starting with day 1")
            
                    logging.info(f"=== CONFIRMED: Generating log for day {next_day} ===")
            
                    # When saving files, double-check the day number
                    log_filename = f"Captains Log day {next_day}.txt"
                    audio_filename = f"Captains Log day {next_day}.mp3"  # Simplified audio filename
                    
                    # Verify the file doesn't already exist before proceeding
                    blob_client = container_client.get_blob_client(log_filename)
                    try:
                        blob_client.get_blob_properties()
                        logging.error(f"File already exists: {log_filename}")
                        raise ValueError(f"File already exists: {log_filename}")
                    except Exception as e:
                        if "BlobNotFound" in str(e):
                            logging.info(f"Confirmed file does not exist: {log_filename}")
                        else:
                            raise
            
                    # Read all previous logs if they exist
                    previous_logs = []
                    # Read all previous logs from Azure
                    for log_file in log_files:
                        blob_client = container_client.get_blob_client(log_file)
                        previous_logs.append(blob_client.download_blob().readall().decode('utf-8'))
            
                    Context = """
            THIS IS WHERE THE SUPER AMAZING PIRATE PROMPT NORMALLY LIVES, 
            BUT CONTAINS MASSIVE CHARACTER AND STORY SPOILERS, SO I'VE REMOVED IT!
            
            """
            
                    # Get token counts for the context
                    context_tokens = client.chat.completions.create(
                        model="gpt-4-turbo",
                        messages=[{"role": "developer", "content": Context}],
                        max_tokens=1  # Minimal response to just get token count
                    ).usage.prompt_tokens
            
                    logging.info(f"Context tokens: {context_tokens}")
            
                    # Track tokens for previous logs
                    previous_logs_tokens = 0
                    messages = [{"role": "developer", "content": Context}]
            
                    # Read all previous logs and count their tokens
                    for log_file in log_files:
                        blob_client = container_client.get_blob_client(log_file)
                        log_content = blob_client.download_blob().readall().decode('utf-8')
                        previous_logs.append(log_content)
                        messages.append({"role": "assistant", "content": log_content})
                        
                        log_tokens = client.chat.completions.create(
                            model="gpt-4-turbo",
                            messages=[{"role": "assistant", "content": log_content}],
                            max_tokens=1
                        ).usage.prompt_tokens
                        previous_logs_tokens += log_tokens
                        logging.info(f"Log entry tokens: {log_tokens}")
            
                    if previous_logs:
                        messages.append({
                            "role": "developer", 
                            "content": "Please write the next journal entry, continuing the story from all previous logs while maintaining consistency in the story and character development.  Do **not** stop early. If you feel the response is complete, keep expanding with more vivid descriptions, character thoughts, and action.  Add extra detail, dialogue, and inner monologues if needed."
                        })
            
                    messages.append({
                        "role": "developer", 
                        "content": "You MUST write a complete log entry using the full 4096 tokens. Do not stop early. Take your time, add more details, inner monologues, or setup for future events. Keep writing until you hit the token limit."
                    })
            
                    completion = client.chat.completions.create(
                        model="gpt-4-turbo",
                        store=True,
                        messages=messages,
                        max_tokens=4096,
                        stop=None,
                        temperature=0.8
                    )
            
                    ai_message = completion.choices[0].message.content
                    finish_reason = completion.choices[0].finish_reason  # Get the finish reason
                    
                    # Get output tokens count
                    output_tokens = client.chat.completions.create(
                        model="gpt-4-turbo",
                        messages=[{"role": "assistant", "content": ai_message}],
                        max_tokens=1
                    ).usage.prompt_tokens
            
                    # Log token usage statistics - making it more visible with separate log entries
                    usage = completion.usage
                    logging.info("========== TOKEN USAGE STATISTICS ==========")
                    logging.info(f"Prompt Tokens: {usage.prompt_tokens}")
                    logging.info(f"Completion Tokens: {usage.completion_tokens}")
                    logging.info(f"Output Tokens: {output_tokens}")
                    logging.info(f"Total Tokens: {usage.total_tokens}")
                    logging.info(f"Previous Logs Tokens: {previous_logs_tokens}")
                    logging.info(f"Context Tokens: {context_tokens}")
                    logging.info(f"Finish Reason: {finish_reason}")  # Log the finish reason
                    logging.info("===========================================")
            
                    logging.info(f"Successfully generated completion for day {next_day}")
            
                except Exception as e:
                    logging.error(f"OpenAI API error: {str(e)}", exc_info=True)
                    raise
            
                try:
                    # Save text to Azure
                    log_filename = f"Captains Log day {next_day}.txt"
                    blob_client = container_client.get_blob_client(log_filename)
                    blob_client.upload_blob(ai_message.encode('utf-8'), overwrite=True)
                    logging.info(f"Successfully saved text to blob: {log_filename}")
            
                except Exception as e:
                    logging.error(f"Blob storage error: {str(e)}", exc_info=True)
                    raise
            
                # Split text into chunks of 4000 characters at sentence boundaries
                def split_text(text, chunk_size=4000):
                    chunks = []
                    current_chunk = ""
                    sentences = text.split('. ')
                    
                    for sentence in sentences:
                        if len(current_chunk) + len(sentence) < chunk_size:
                            current_chunk += sentence + '. '
                        else:
                            chunks.append(current_chunk)
                            current_chunk = sentence + '. '
                    if current_chunk:
                        chunks.append(current_chunk)
                    return chunks
            
                # Split text into chunks and process audio
                try:
                    logging.info('Starting text chunk processing...')
                    text_chunks = split_text(ai_message)
                    logging.info(f'Successfully split text into {len(text_chunks)} chunks')
            
                    # Create a single audio file regardless of chunks
                    audio_filename = f"Captains Log day {next_day}.mp3"
                    combined_audio = BytesIO()
                    
                    logging.info(f'Processing {len(text_chunks)} audio chunks...')
                    for i, chunk in enumerate(text_chunks):
                        try:
                            logging.info(f'Processing chunk {i+1} of {len(text_chunks)}')
                            speech_response = client.audio.speech.create(
                                model="tts-1",
                                voice="ash",
                                input=chunk
                            )
                            # Append this chunk's audio data to our combined buffer
                            combined_audio.write(speech_response.content)
                            
                        except Exception as e:
                            logging.error(f"ERROR processing audio chunk {i+1}: {str(e)}", exc_info=True)
                            raise
            
                    # Reset buffer position to start
                    combined_audio.seek(0)
                    
                    # Upload the single combined audio file
                    blob_client = container_client.get_blob_client(audio_filename)
                    blob_client.upload_blob(combined_audio.getvalue(), overwrite=True)
                    logging.info(f"Successfully saved combined audio to blob: {audio_filename}")
            
                    logging.info('Audio processing completed successfully')
            
                    try:
                        # Log text response details
                        logging.info(f"Text response length: {len(ai_message)}")
                        logging.info(f"Text saved to Azure as {log_filename}")
                    except Exception as e:
                        logging.error(f"Error logging text details: {str(e)}", exc_info=True)
                        # Don't raise here, continue to function completion
            
                    try:
                        # Function completion message
                        logging.info('Python timer trigger function completed successfully')
                        return  # Explicitly return from the function
                    except Exception as e:
                        logging.error(f"Error in final logging: {str(e)}", exc_info=True)
                        # Don't raise here, let function complete
            
                except Exception as e:
                    logging.error(f"Critical error in audio processing: {str(e)}", exc_info=True)
                    raise
            
            
            </code></pre>
          <br><br>
          Oh yea, remember way back when, when I had the issues with the audio files, and getting them stiched together ? and I mentioned it would be a problem later ?
          <br>
          Well turns out the that Pydub (which was the libary i was using to stiche the audio files together), requires FFmpeg to be installed to work.
          <br>Of course this didn't exsist within my Azure Function, so when i first migrated everything, i had a bunch of errors and couldn't understand why the script kept crashing.
          <br>Turns out, this was the issue.
          <br><br>Thats why i ended up changing to BytesIO, which turned out to be a much better solution.
          <br>BytesIO is a file-like object in Python that allows you to read and write binary data in memory (RAM) instead of a physical file.
          <br>This is much more efficient and faster than using a physical file, so it actaully turned out to be a blessing in disguise.
          <br>
          <br>
          Okay recap time again!
          <br>
          <br>
          We now have the code for the AI Agent inside an Azure Function, the function is triggered by a Time-Trigger, which means it will run at a specific time each day.
          <br>
          <br>
          The function will then generate a new episode, save the .txt file from the output, and the .mp3 file to the Azure Blob Storage.
          <br>
          <br>
          Perfect, we are making progress!
          <br>
          <br>
          Now we just need create a container on the website, which will house the audio player, and to figure out how to automcatailly update the website whenever a new episode is avaialble in the blob storage.
          <br>
          <h2>HTTP Triggers - Making me want to pull the trigger on myself</h2>
          This next section, was by far the most difficult part of the whole project.
          <br>I knew what HTTP Triggers were, but i had never worked with them before, again, i'm not a web developer, so this was a fairly new concept for me.
          <br>This combined with my pathetic lack of knowledge when it comes to javascript, ment this was gunna be a real challenge.
          <br><br>For this all to work seemlessly, i needed HTML, Python, javascript, HTTP Triggers and a whole lot of trial and error!
          <br><br>Luckily for me, i had my two new best friends at the ready! - ChatGPT and Cursor!
          <br><br>Okay, time to tackle the first step, getting any episodes in the blog container, to be streamable on the site, and all new episodes to be added to the site automatically.
         <h2>Azure Function - Loading the Episodes</h2>
         Okay this step will consist of a few different working parts.
         <br><br>
         Firstly, i will need to create the HTML code for the episodes container on the website.
         <br>
         This will be the area where the each epeisode will be loaded, and the embeded audio player will be loaded for each episode.
         <br>
         <h3>The HTML Code</h3>
         <pre class="line-numbers"><code class="language-html">
          &lt;!-- Main Content -->
          &lt;div class="content-wrapper">
              &lt;div class="episode-container" id="episodeContainer">
                  &lt;article
                      class="loading-container"
                      id="loadingSpinner"
                      style="display: none"
                  >
                      &lt;div class="pirate-ship">
                          &lt;img
                              src="/images/pirate-ship.svg"
                              alt="Loading animation - Pirate ship"
                          />
                      &lt;/div>
                      &lt;p class="loading-text">Loading the Captain's Log...&lt;/p>
                  &lt;/article>
                  &lt;div id="errorContainer" class="error-container" role="alert">&lt;/div>
                  &lt;div id="episodeContainer" role="feed" aria-label="Episodes list">&lt;/div>
                  &lt;nav id="paginationContainer" aria-label="Episodes pagination">&lt;/nav>
                  &lt;!-- Episodes will be dynamically inserted here -->
              &lt;/div>
          &lt;/div>
          </code></pre>
          <br>I also created a mega cute little pirate ship, which is a little animation that will play.
          <br>This serves as a placeholder for when no episodes are available, or when episodes are loading.
          <br><br>
          Obviously, this also consisted of a bunch of css work in the styles.css file, and a bit of javascript to make the animaiton of on the ship.
         <br>
         <br>
         <img src="/images/rockingship.gif" alt="Rocking ship" style="width: 70%;">
         <br><br>
         God dam it's so cute and charming, this might be my favorite part of the entire website!
         <br><br>Anyhow, now we need to create some Javascript to make a HTTP request to an Azure Function, requesting any available episodes.
         <h3>The JavaScript Code</h3>
         <pre class="line-numbers"><code class="language-javascript">
         async function fetchEpisodes(page = 1, itemsPerPage = 10) {
             console.log(`Fetching episodes for page ${page} with ${itemsPerPage} items per page`);
             const loadingSpinner = document.getElementById('loadingSpinner');
             const errorContainer = document.getElementById('errorContainer');
             const episodeContainer = document.getElementById('episodeContainer');
             const paginationContainer = document.getElementById('paginationContainer');
         
             try {
                 if (loadingSpinner) loadingSpinner.style.display = 'block';
                 if (errorContainer) errorContainer.style.display = 'none';
                 
                 const functionUrl = AZURE_FUNCTION_URL;
                 
                 console.log('Making API request...');
                 const response = await fetch(functionUrl);
                 if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                 
                 const data = await response.json();
                 console.log(`Received ${data.blobs?.length || 0} episodes from API`);
         
                 if (!data.blobs || !Array.isArray(data.blobs) || data.blobs.length === 0) {
                     if (episodeContainer) {
                         episodeContainer.innerHTML = `
                             &lt;div class="loading-container"&gt;
                                 &lt;div class="pirate-ship"&gt;
                                     &lt;img src="/images/pirate-ship.svg" alt="Loading..." /&gt;
                                 &lt;/div&gt;
                                 &lt;div class="loading-text"&gt;New episodes coming soon! ‚ò†Ô∏è&lt;/div&gt;
                             &lt;/div&gt;
                         `;
                     }
                     if (paginationContainer) {
                         paginationContainer.innerHTML = '';
                     }
                     return;
                 }
         
                 // Sort episodes
                 const episodes = data.blobs.sort((a, b) => {
                     const dayA = parseInt(a.name.match(/day (\d+)/i)[1]);
                     const dayB = parseInt(b.name.match(/day (\d+)/i)[1]);
                     return dayB - dayA;
                 });
             }
         }</code></pre>

         <br><br>And finally we have the Azure Function that will handle the request!
         <h3>The Azure Function Code</h3>
         <pre class="line-numbers"><code class="language-python">
          const { BlobServiceClient, StorageSharedKeyCredential, generateBlobSASQueryParameters, BlobSASPermissions } = require('@azure/storage-blob');

          module.exports = async function (context, req) {
              context.log('Function starting - testing blob storage connection');
              
              try {
                  const connectionString = process.env.AZURE_STORAGE_CONNECTION_STRING;
                  const containerName = process.env.CONTAINER_NAME;
                  
                  // Parse connection string to get account name and key
                  const accountName = connectionString.match(/AccountName=([^;]+)/)[1];
                  const accountKey = connectionString.match(/AccountKey=([^;]+)/)[1];
                  
                  const sharedKeyCredential = new StorageSharedKeyCredential(accountName, accountKey);
                  const blobServiceClient = BlobServiceClient.fromConnectionString(connectionString);
                  const containerClient = blobServiceClient.getContainerClient(containerName);
          
                  const blobs = [];
                  for await (const blob of containerClient.listBlobsFlat()) {
                      if (blob.name.toLowerCase().endsWith('.mp3')) {
                          const blobClient = containerClient.getBlobClient(blob.name);
                          
                          // Generate SAS token for this blob
                          const startsOn = new Date();
                          const expiresOn = new Date(new Date().valueOf() + 3600 * 1000); // 1 hour from now
                          
                          const sasOptions = {
                              containerName: containerName,
                              blobName: blob.name,
                              permissions: BlobSASPermissions.parse("r"),  // Read only
                              startsOn: startsOn,
                              expiresOn: expiresOn,
                          };
                          
                          const sasToken = generateBlobSASQueryParameters(
                              sasOptions,
                              sharedKeyCredential
                          ).toString();
                          
                          // Construct URL with SAS token
                          const sasUrl = `${blobClient.url}?${sasToken}`;
          
                          blobs.push({
                              name: blob.name,
                              url: sasUrl,  // Use the SAS URL instead of the direct blob URL
                              size: blob.properties.contentLength,
                              lastModified: blob.properties.lastModified
                          });
                      }
                  }
          
                  context.res = {
                      status: 200,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      body: {
                          message: "Successfully retrieved blobs",
                          blobCount: blobs.length,
                          blobs: blobs
                      }
                  };
                  
              } catch (error) {
                  context.log.error('Function failed:', error);
                  context.res = {
                      status: 500,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      body: {
                          error: 'Function failed',
                          message: error.message,
                          timestamp: new Date().toISOString()
                      }
                  };
              }
          };
         </code></pre>
         <br>
         <br>
         Okay, at this point your probably thinking, "how the fuck does this work?"
         <br>
         <br>
         Well, let me explain.
         <br>
         <br>
         <div class="tenor-gif-embed" data-postid="18564553" data-share-method="host" data-aspect-ratio="1.57635" data-width="100%"><a href="https://tenor.com/view/charlie-day-gif-18564553">Charlie Day GIF</a>from <a href="https://tenor.com/search/charlie-gifs">Charlie GIFs</a></div> <script type="text/javascript" async src="https://tenor.com/embed.js"></script>
         <br>
         <br>
         <img src="/images/howitworks.png" alt="How it works">
              <br>     
              <br>  
              So with this method, as soon as .mp3 file is available in the blob storage, the media player will automatically update and display the new episode ready for streaming!
              <br><br>
              <img src="/images/mediaplayer.png" alt="Media Player">
                <br>
                <h2>Azure Function - The Subscribe Feature</h2>
                Okay, at this point i'm almost 2 weeks deep into this project.
                <br>What went from being a quick "in out adventure" into the world of AI Agents, has now turned into a full blown project. Consuming all of my free evenings, and weekends.
                <br><br>
                <div class="tenor-gif-embed" data-postid="22364490" data-share-method="host" data-aspect-ratio="1.77778" data-width="50%"><a href="https://tenor.com/view/rick-morty-rick-and-morty-20minutes-adventure-quick-adventure-gif-22364490">Rick Morty GIF</a>from <a href="https://tenor.com/search/rick-gifs">Rick GIFs</a></div> <script type="text/javascript" async src="https://tenor.com/embed.js"></script>
                <br><br>I'm obsessed, and i need to bring this project to fruition!
                <br>
                <br>
                However, if i'd had known how much work this was about to become, for such a minor feature (That probablly barely anyone will use), i'd had probably just had left it out.
                <br><br>I'm not going to lie, this was a royal ball ache to get working!
                <br><br>
                But, i'll be honest, i'm glad i went through with it, because it was a great learning experience, and i'm sure there are a few people who will use it.
                <br>
                <br>
                So lets break it down.
                <br>
                <br>We need some sort of a "sign up" form on the website.
                <br>We then need some way of storing emails in a database.
                <br>Then we need a way of monitoring the blob storage for new episodes.
                <br>If a new episode is found in blob storage it should trigger 2 functions.
                <br>1. The function we have already built, that loads the episdoes to the website.
                <br>2. A new function that emails all emails addresses in the database, informing them that a new episode is available.
                <br>
                <h3>Step 1 - Storing users Emails in a database</h3>
                Okay firstly we create a nice looking subscription form, matching the style of the rest of the website.
                <br>
                <br>
                <img src="/images/subscribebox.png" alt="Subscribe Form">
                <br><br>
                Then we create some Javasrcipt to handle the form submission.
                <br> Along with some error handling, to give the user feedback on their submission.
                <br>
                For example: We need to make some simple checks like, is the email already in the database, is the input in a valid email address format etc.
                <br>
                <br>
                <pre class="line-numbers"><code class="language-javascript">
                  // Single form submission handler
                  emailForm.addEventListener('submit', async function(e) {
                      e.preventDefault();
                      const email = document.getElementById('emailInput').value;
                      const submitButton = emailForm.querySelector('button[type="submit"]');
                      
                      try {
                          submitButton.disabled = true;
                          submitButton.textContent = 'Subscribing...';
                          errorDiv.textContent = '';
                          errorDiv.className = 'error-message';
                          
                          const response = await fetch('AZURE_FUNCTION_URL', {
                              method: 'POST',
                              headers: {
                                  'Content-Type': 'application/json',
                              },
                              body: JSON.stringify({ email })
                          });
              
                          const data = await response.json();
              
                          if (response.status === 200) {
                              errorDiv.textContent = 'Thank you for subscribing! üè¥‚Äç‚ò†Ô∏è';
                              errorDiv.className = 'error-message success';
                              emailForm.reset();
                              setTimeout(closeModal, 2000);
                          } else if (response.status === 400 && data.error === 'Email already exists in database') {
                              errorDiv.textContent = 'You are already signed up! ‚öì';
                              errorDiv.className = 'error-message warning';
                          } else {
                              errorDiv.textContent = 'Failed to subscribe. Please try again.';
                              errorDiv.className = 'error-message error';
                          }
                      } catch (error) {
                          console.error('Subscription error:', error);
                          errorDiv.textContent = 'A problem occurred. Please try again later.';
                          errorDiv.className = 'error-message error';
                      } finally {
                          submitButton.disabled = false;
                          submitButton.textContent = 'Subscribe';
                      }
                  });
              
                  function closeModal() {
                      modal.style.display = 'none';
                      document.body.style.overflow = 'auto';
                      emailForm.reset();
                      errorDiv.textContent = '';
                      errorDiv.className = 'error-message';
                  }
              
              
                </code></pre>
                <br><br>
                My original plan for the storing the email addresses was to use an Azure SQL database, but that would actually be overkill for this project.
                <br>
                So instead I ended up using Azure table storage, which is a much simpler and cheaper solution.
                <br><br>
                I created a table in the exsisting azure storage account, and then created a new function to handle the requests.
                <br><br>
                <pre class="line-numbers"><code class="language-javascript">
                  const { TableClient, odata } = require("@azure/data-tables");

                  module.exports = async function (context, req) {
                      context.log('Starting email subscription process...');
                  
                      try {
                          // Enable CORS
                          context.res = {
                              headers: {
                                  'Access-Control-Allow-Credentials': 'true',
                                  'Access-Control-Allow-Origin': '*',
                                  'Access-Control-Allow-Methods': 'POST, OPTIONS',
                                  'Access-Control-Allow-Headers': 'Content-Type',
                              }
                          };
                  
                          // Handle preflight requests
                          if (req.method === 'OPTIONS') {
                              context.res.status = 204;
                              return;
                          }
                  
                          // Validate request
                          const email = req.body && req.body.email;
                          if (!email) {
                              throw new Error('Email is required');
                          }
                  
                          // Connect to Table Storage
                          const tableClient = TableClient.fromConnectionString(
                              process.env.STORAGE_CONNECTION_STRING,
                              "Subscribers"
                          );
                  
                          // Check if email already exists
                          try {
                              await tableClient.getEntity("subscribers", email.toLowerCase());
                              // If we get here, the email exists
                              context.res = {
                                  status: 400,
                                  headers: {
                                      'Content-Type': 'application/json',
                                      'Access-Control-Allow-Origin': '*'
                                  },
                                  body: { 
                                      error: 'Email already exists in database'
                                  }
                              };
                              return;
                          } catch (error) {
                              // If error is "not found", continue with subscription
                              if (error.statusCode !== 404) {
                                  throw error;
                              }
                          }
                  
                          // Create entity
                          const entity = {
                              partitionKey: "subscribers",
                              rowKey: email.toLowerCase(),
                              email: email,
                              dateAdded: new Date().toISOString()
                          };
                  
                          // Add to table
                          await tableClient.createEntity(entity);
                  
                          context.res = {
                              status: 200,
                              headers: {
                                  'Content-Type': 'application/json',
                                  'Access-Control-Allow-Origin': '*'
                              },
                              body: { 
                                  message: 'Subscription successful' 
                              }
                          };
                  
                      } catch (error) {
                          context.log.error('Detailed error:', {
                              message: error.message,
                              stack: error.stack,
                              name: error.name
                          });
                          
                          context.res = {
                              status: 500,
                              headers: {
                                  'Access-Control-Allow-Origin': '*',
                                  'Content-Type': 'application/json'
                              },
                              body: {
                                  error: error.message || 'Failed to process subscription'
                              }
                          };
                      }
                  };
                </code></pre>
                <br>
                The function also does a few pre flight checks, to make sure the email is valid, and that it doesn't already exist in the database.
                <br>
                <br>
                If these checks pass, the function will add the email to the table, under the "subscribers" partition key, and add a timestamp to the record.
                <br>
                <br>
                Awesome users now have the ability to subscribe to the Captain's Journal!
                <br>
                <h3>Creating the unsubscribe feature</h3>
                Okay, now that we have given people the ability to subscribe, we also need to give them the ability to unsubscribe.
                <br>
                If i'm going to be doing daily releases, people might get fed up of getting emails everyday, so it's only fair they have the option to unsubscribe.
                <br>
                <br>
                Basicly, we just need to build a new function, that does the apposite of the subscribe function we just built.
                <br>Instead of adding an email to the database, it will search for a specific email in the database, if it finds the email, it will remove it from the database.
                <br><br>
                However, there is a small caveat.
                <br>
                This can't be a button on the website, or a trigger from the website. It has to be a link inside the email end users recieve, when a new episode goes live.
                <br><br>
                <img src="/images/unsublink.png" alt="Unsubscribe Link">
                <br><br>
                We're using another Azure function to send this email (which we'll get to in a moment) but here's a snippet of the part of the code, that actually creates the email and the link inside the email.
                <br><br>
                <img src="/images/emailcode.png" alt="Email Code">
                <br><br>
                So how does this work?
                <br><br>
                The important thing to take note of here, is the link in the buttom of the code.
                <br>Take note of the (EncodeURIComponent(email)) part.
                <br>What this does is, it encodes the email address of the user that clicked the link, into the actual link itself.
                <br>When the user clicks the link, it redirects the user to https://captains-journal.com/unsub - Navigating to this page normally will do nothing.
                <br>However, navigating to the page with a encoded email address in the URL, will trigger a small script.
                <br><br>
                <pre class="line-numbers"><code class="language-javascript">
                    document.addEventListener("DOMContentLoaded", async () => {
                        const urlParams = new URLSearchParams(window.location.search);
                        const email = urlParams.get("email");
                        const messageDiv = document.getElementById("message");
                    
                        console.log("Email from URL:", email);
                    
                        if (!email) {
                            messageDiv.textContent = "Invalid unsubscribe link - no email provided";
                            messageDiv.className = "message error";
                            return;
                        }
                    
                        try {
                            const apiUrl = `https://app-func-captainslog.azurewebsites.net/api/UnsubscribeEmail?email=${encodeURIComponent(email)}`;
                            console.log("Calling API:", apiUrl);
                    
                            const response = await fetch(apiUrl, {
                                method: "GET",
                                headers: {
                                    Accept: "application/json",
                                    "Cache-Control": "no-cache",
                                },
                            });
                    
                            console.log("Response status:", response.status);
                    
                            const responseText = await response.text();
                            console.log("Response text:", responseText);
                    
                            let data;
                            try {
                                // Only try to parse JSON if we have a response
                                if (responseText) {
                                    data = JSON.parse(responseText);
                                } else {
                                    throw new Error("Empty response from server");
                                }
                            } catch (parseError) {
                                console.error("Failed to parse JSON:", parseError);
                                throw new Error(
                                    `Server response error: ${responseText || "No response"}`
                                );
                            }
                    
                            if (response.ok) {
                                messageDiv.textContent = `You have been successfully unsubscribed from the Captain's Journal newsletter.`;
                                messageDiv.className = "message success";
                            } else {
                                messageDiv.textContent =
                                    data?.error || "Failed to unsubscribe. Please try again later.";
                                messageDiv.className = "message error";
                            }
                        } catch (error) {
                            console.error("Error:", error);
                            messageDiv.textContent = `Error: ${error.message}`;
                            messageDiv.className = "message error";
                        }
                    });
                    </code></pre>
                <br>This script will then trigger the Azure unsubscribe function, passing on the encoded email address within the link.
                <br>The Azure function will then scan the database for the email address, if the email address is found, it will be removed from the database.
                <br><br>
                <h3>The Unsubscribe Function</h3>
                <pre class="line-numbers"><code class="language-python">
                  import logging
                  import azure.functions as func
                  from azure.data.tables import TableServiceClient
                  from azure.core.exceptions import ResourceNotFoundError
                  import json
                  import os
                  
                  def main(req: func.HttpRequest) -> func.HttpResponse:
                      logging.info('UnsubscribeEmail function triggered')
                  
                      headers = {
                          "Content-Type": "application/json",
                          "Access-Control-Allow-Origin": "*"
                      }
                  
                      try:
                          email = req.params.get('email')
                          logging.info(f'Processing unsubscribe request for email: {email}')
                  
                          if not email:
                              return func.HttpResponse(
                                  body=json.dumps({"error": "Email parameter is required"}),
                                  headers=headers,
                                  status_code=400
                              )
                  
                          # Connect to table storage
                          connection_string = os.environ["AZURE_STORAGE_CONNECTION_STRING"]
                          table_service = TableServiceClient.from_connection_string(connection_string)
                          table_client = table_service.get_table_client("subscribers")
                          
                          try:
                              # Use the known partition key and email as row key
                              partition_key = "subscribers"
                              row_key = email
                              
                              logging.info(f'Attempting to delete entity with PartitionKey: {partition_key}, RowKey: {row_key}')
                              
                              # Delete the entity
                              table_client.delete_entity(
                                  partition_key=partition_key,
                                  row_key=row_key
                              )
                              
                              logging.info(f'Successfully deleted entity for email: {email}')
                              return func.HttpResponse(
                                  body=json.dumps({
                                      "message": "Successfully unsubscribed",
                                      "email": email
                                  }),
                                  headers=headers,
                                  status_code=200
                              )
                              
                          except ResourceNotFoundError:
                              logging.warning(f'No subscription found for email: {email}')
                              return func.HttpResponse(
                                  body=json.dumps({
                                      "error": "Email not found or already unsubscribed"
                                  }),
                                  headers=headers,
                                  status_code=404
                              )
                              
                          except Exception as e:
                              logging.error(f'Table operation error: {str(e)}')
                              return func.HttpResponse(
                                  body=json.dumps({
                                      "error": f"Failed to process unsubscribe request: {str(e)}"
                                  }),
                                  headers=headers,
                                  status_code=500
                              )
                  
                      except Exception as e:
                          logging.error(f'Error: {str(e)}')
                          return func.HttpResponse(
                              body=json.dumps({
                                  "error": f"Internal server error: {str(e)}"
                              }),
                              headers=headers,
                              status_code=500
                          );
                  </code></pre>
                 <br>The function then passes the result back to the script, which then displays a message to the user, informing them that they have been unsubscribed from the newsletter.
                 <br><br>
                 <img src="/images/unsubexample.png" alt="Unsubscribe Example">
                  <br><br> This is the part that really broke me. There are so many moving parts to this, and everything has to work in sync, or it wont work.
                  <br><br>but oh boy does it feel good watching it work like a well oiled machine!
                 <h3>Sending Emails when a new episdoe goes live</h3>
                Okay, we're almost there! Time for the final peice of the puzzle!
                <br><br> We need to create a Function that will send an email to all users in the database when a new episode goes live.
                <br><br>
                This part was actually surprisingly simple.
                <br><br>Turns out, Azure functions have a built in trigger called a "Blob Trigger".
                <br>This trigger is used to trigger a function when a new blob is created in the storage account
                <br>(Or in our case, when a new episode is created).
                <br>
                <br>
                Basicly, we just write a simple script that triggers when a new item is created in the blob storage, the script then checks if it's a .mp3 file.
                <br>if the new blob is a .mp3 file, the script then sends an email to all email addresses in the database informing them that a new episode is available.
                <br>
                <br>
                <h3>The Blob Trigger Function</h3>
                <pre class="line-numbers"><code class="language-javascript">
         
const { TableClient } = require("@azure/data-tables");
const nodemailer = require("nodemailer");

module.exports = async function (context, myBlob) {
    context.log("Blob trigger function processed blob:", context.bindingData.name);

    try {
        // Only process .mp3 files
        if (!context.bindingData.name.toLowerCase().endsWith('.mp3')) {
            context.log('Not an MP3 file, skipping...');
            return;
        }

        // Get all subscribers from Table Storage
        const tableClient = TableClient.fromConnectionString(
            process.env.STORAGE_CONNECTION_STRING,
            "Subscribers"
        );

        const subscribers = [];
        const iterator = tableClient.listEntities();
        for await (const entity of iterator) {
            subscribers.push(entity.email);
        }

        context.log(`Found ${subscribers.length} subscribers`);

        // Configure email transport for Microsoft 365
        const transporter = nodemailer.createTransport({
            host: "smtp.office365.com",
            port: 587,
            secure: false, // true for 465, false for other ports
            auth: {
                user: process.env.EMAIL_USER, // Your Microsoft 365 email
                pass: process.env.EMAIL_PASS  // Your Microsoft 365 password or app password
            },
            tls: {
                ciphers: 'SSLv3'
            }
        });

        // Send emails to all subscribers
        const episodeName = context.bindingData.name.replace('.mp3', '');
        
        for (const email of subscribers) {
            // ... (keep all the code the same until the sendMail part) ...

            // ... (keep all the code the same until the sendMail part) ...

         // ... (keep all the code the same until the sendMail part) ...

await transporter.sendMail({
    from: process.env.EMAIL_USER,
    to: email,
    subject: `New Episode: ${episodeName}`,
    html: `
  INSIDE THIS AREA OF THE SCRIPT IS THE HTML CODE FOR THE EMAIL, WHICH I SHOWED IN THE PREVIOUS SECTION.
  I CAN'T DISPLAY IT IN THIS PREVIEW SINCE THE PREVIEW IS SET TO JUST DISPLAY THE JAVASCRIPT CODE.
  THE SCREENSHOT WITH THE  (EncodeURIComponent(email)) LINK

// ... (keep the rest of the code the same) ...

// ... (keep the rest of the code the same) ...

// ... (keep the rest of the code the same) ...
            context.log(`Email sent to ${email}`);
        }

        context.log('All notification emails sent successfully');

    } catch (error) {
        context.log.error('Error processing blob trigger:', error);
        throw error;
    }
};
                </code></pre>
                <br> We have a fully automated system that sends emails to all users in the database when a new episode goes live!
                <h2>Testing testing and more testing</h2>
                WOW! I made it - I finally built this thing!</i>
                <br><br>An entire tech stack, but the question is, does everything work?
                <br><br>Amazingly enough, YES! Everything seems to be working flawlessly.
                <br><br>There is only one issue i've noticed so far!
                <br><br>If you recall way back when i first talked about fuctions, i mentioned some of the caveats of using the free tier of Azure functions 
                <br>Namely, "Cold Start Latency: Infrequently used functions may experience delays during startup, potentially impacting performance for time-sensitive applications"
                <br>This is definitely noticable with regards to the function that loads the episodes to the site. Sometimes it can take up to 30 seconds to display the episosdes....
                <br><br>It's not because the website is slow, it's simplely because the function is "sleeping" and it takes a few seconds to wake up.
                <br><span style="color: red;">(Doesn't this inherantly just mean the website is actaully slow?)</span>
                <br>SHUT UP FUTURE JAKE!!!!!!  WHO IS ONLY HERE BEACAUSE HE HAS TO PROOF READ THIS ENTIRE GOD DAM BLOG!!!!!!
                <br><br>Other than this, the majourity of my time spent testing, has been generating stories, testing different prompts, styles and AI settings.
                <br>Oh, and experimenting with epicly themed pirate voices, narrated by yours truely! (Wink Wink)
                <br><br>This is without a doubt the most important part of the entire project!
                <br>If the story and charcacters are not fun/entertaining, and i can't control the AI Agent from going completely rouge, the entire website, the Azure functions, the AI agent, and the absurde amount of time i spent on that stupid subscriber function, exsists for nothing.
                <br><br>PLEASE FOR THE LOVE OF GOD, SOMEONE PLEASE SUBSCRIBE, JUST ONE PERSON, JUST LET ME SEE THAT SWEET PROCESS RUN ONCE!!
                <br><br>Ahhhhh... i digress, I will be spending the next few days trying to get this as dialed in as best as possible. I want to bring you guys the best pirating squash buckeling adventure, ye land lubbers could ever ask for...FOR I AM NOT CALLED CAPTAIN ADMIRAL FANCYBOOTS THE THIRD FOR NOTHING!!
                <br><br>HMMPHEE *Cough Cough" *Clears throat* *Cough Cough* - sorry, i'm not quite sure what happened there...
                <br><br>Anyhow, on to some housekeeping...
                <h2>Housekeeping</h2>
                Now that the website is built, there is a few housekeeping things I need to take care of.
                <h4>Creating a personal email adddress for the captain</h4>
                Being a Microsoft 365 guy, and since everything is allready hosted in Azure, the logical option here is to just create a new email address using Microsoft 365.
                <br>So i added the "captains-journal" domain to my M365 tenant, and created the email address thecaptain@captains-journal.com
                <br>Gave the account an exchange online license, and we're good to go!
                <br>Had a few issues with emails ending up in spam folders when i tested with some personal accounts, so i ended up fixing SPF, DKIM, and DMARC for the domain, which will hopefully sort that out.
                <br>This will be the email address used to send out the notifications when a new episode goes live.
                <br><br>Feel free to use this e-mail address to contact me if you have any questions, or just want to say hi!
                <h4>Meta data - Website tweaks</h4>
                The next part of the housecleaning process was adding all the meta data to the website.
                <br>Nothing really exciiting here, but feel it's worth mentioning, since it's pretty important these days.
                <br>Just simple stuff like - If a user links the site in a whatsapp group, or a facebook/instagram post, it displays the correct image, title, description etc.
                <br> Just trying to make things look a bit more professional, and help with SEO.
                <br><br>I'll also spend some time making a few tweaks, making sure performance is good, and maybe, just maybe, i'll get around to building that character bios page i mentioned a while back.
                <h4>Function keys</h4>
                This ones a big one.
                <br><br> A lot of the functions i built when testing, used function keys which were visable in pain text in the client side javascript.
                <br>This is a big no-no, so i'll need to fix this before i go live.
                <br></BR>It's not really a big security concern, given the content of my website, and the functions i'm using, but it could be a big conern for my wallet!
                <br><br>If someone got access to my functions, they could potentially just constantly call the funcitons, sending API calls to OPENAI and creating runs in Azure, which could ultimately end up costing me a lot of money!
                <br>Ethier way, i'm doing things right, so that will be fixed before launch!
                <<h2>The final chapter - Doubt.....</h2>
                It's time, i can't run from it any longer, it's time to release the website to the rest of the world.
                <br><br>What a weird feeling......
                <br><br>I've been so consumed by this for weeks now, the thought of openly putting my work out to the public is a scary one.
                <br>Some people know i've been working on something, but nobody has actually seen anything - It's been my own little secret getaway.
                <br>It's a strange combination of excitment and anxiety. I'm excited to see peoples reactions, but on the other hand, i'm nervous about the feedback i'll get.
                <br><br>I guess this is only natural when you've been working on something for a while, and it's finally time to let it out into the wild.
                <br><br>But yet, i can't shake certain doubts....
                <br><br>What if the first episode the AI generates is completely wild, and it goes completely off the rails?- If the first episode is bad, it's not going to bring people in.
                <br> Will the website suddenly crash and burn if it starts to get a lot of traffic?
                <br>Is there something critcal i've overseen?
                <br>Did i leave sensitive information visable in code?
                <br><br>Will people even care?
                <br><br>But then i remind myself how this all started.....
                <br><br>I didn't build this to impress anyone. I didn't build this for my CV, and I certainly didn't build this to make a quick buck. It all stemmed from a simple curiosity about AI Agents‚Äîjust a spark of an idea that grew into something bigger than I ever expected.
                <br> Along the way, I've learned so much, not just about AI and building things, but about the process of creating something from nothing. And the best part? This is just the beginning. I already have a ton of ideas for future projects, and I can't wait to explore them.
                <br><br>Oh, and to circle all the way back to the start of this blog‚Ä¶ YUP!! SAS is most definitely in trouble. AI Agents are going to change the game.
                <br><br>But for now, i've rambled on long enough‚Äîit's time to actually do it.
                <br><br>If you've made it this far, thank you.
                <br> I hope you've enjoyed reading this blog, and maybe, just maybe, my journey will inspire you to build something of your own‚Äîjust like Microsoft CEO interview inspired me.
                <br><br>Every great adventure starts with uncertainty, and every captain has to take that first step onto the deck, not knowing what the seas ahead may bring.
                <br><br>So, here we go. The anchor is up, the wind is in the sails, and The Captain's Journal is officially setting course for the world.
                <br><br>I hope you'll come aboard and join me on this journey. Let's see where the tide takes us. ‚öìüè¥‚Äç‚ò†Ô∏è


               
                
               
                
            </div>
          </section>

          <!-- Creator Section -->
          <section class="about-section creator-section" aria-label="About the Creator">
            <h2>About the Creator</h2>
            <div class="creator-profile">
              <img
                src="/images/profile-photo.png" style="width: 15%; border-radius: 50%"
                class="creator-image"
              />
              <div class="creator-info">
                <h3>Jake Poulsom</h3>
                <p class="creator-title">Microsoft 365 & Azure Expert</p>
                <img src="/images/azure-logo.svg" alt="Microsoft Azure" style="width: 3%" />
                <img src="/images/Microsoft_logo.svg" alt="Microsoft" style="width: 3%" />
                <p class="creator-bio">
                </p>
                <div class="creator-links">
                  <a
                    href="https://www.linkedin.com/in/jake-poulsom-3561271b5/"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="social-link"
                  >
                    LinkedIn
                  </a>
                  <a
                    href="mailto:thecaptain@captains-journal.com"
                    class="social-link"
                  >
                    Contact
                  </a>
                </div>
              </div>
            </div>
          </section>
        </article>
      </div>
    </main>

    <!-- Footer -->
    <footer class="site-footer" role="contentinfo">
      <!-- ... existing footer content ... -->
    </footer>

    <!-- Newsletter Modal -->
    <div id="newsletterModal" class="modal">
      <!-- ... existing newsletter modal content ... -->
    </div>

    <!-- Scripts -->
    <script src="../client.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-markup.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-javascript.min.js"></script>
  </body>
</html>
